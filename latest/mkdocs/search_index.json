{
    "docs": [
        {
            "location": "/", 
            "text": "SQLite.jl Documentation\n\n\n\n\nSQLite.jl Documentation\n\n\nHigh-level interface\n\n\nLower-level utilities\n\n\n\n\n\n\n\n\n\n\nHigh-level interface\n\n\n#\n\n\nSQLite.query\n \n \nFunction\n.\n\n\nSQLite.query(db, sql::String, sink=DataFrame, values=[]; rows::Int=0, stricttypes::Bool=true)\n\n\nconvenience method for executing an SQL statement and streaming the results back in a \nData.Sink\n (DataFrame by default)\n\n\nWill bind \nvalues\n to any parameters in \nsql\n. \nrows\n is used to indicate how many rows to return in the query result if known beforehand. \nrows=0\n (the default) will return all possible rows. \nstricttypes=false\n will remove strict column typing in the result set, making each column effectively \nVector{Any}\n\n\nsource\n\n\n#\n\n\nSQLite.load\n \n \nFunction\n.\n\n\nLoad a Data.Source \nsource\n into an SQLite table that will be named \ntablename\n (will be auto-generated if not specified).\n\n\ntemp=true\n will create a temporary SQLite table that will be destroyed automatically when the database is closed \nifnotexists=false\n will throw an error if \ntablename\n already exists in \ndb\n\n\nsource\n\n\n\n\nLower-level utilities\n\n\n#\n\n\nSQLite.Source\n \n \nType\n.\n\n\nSQLite.Source\n implements the \nSource\n interface in the \nDataStreams\n framework\n\n\nsource\n\n\n#\n\n\nSQLite.Sink\n \n \nType\n.\n\n\nSQLite.Sink implements the \nSink\n interface in the \nDataStreams\n framework\n\n\nsource\n\n\n\n\nTypes/Functions\n\n\n\n\n\n\nSQLite.DB(file::AbstractString)\n\n\nSQLite.DB\n requires the \nfile\n string argument as the name of either a pre-defined SQLite database to be opened, or if the file doesn't exist, a database will be created.\n\n\nThe \nSQLite.DB\n object represents a single connection to an SQLite database. All other SQLite.jl functions take an \nSQLite.DB\n as the first argument as context.\n\n\nTo create an in-memory temporary database, call \nSQLite.DB()\n.\n\n\nThe \nSQLite.DB\n will automatically closed/shutdown when it goes out of scope (i.e. the end of the Julia session, end of a function call wherein it was created, etc.)\n  * \nSQLite.Stmt(db::SQLite.DB, sql::String)\n\n\nConstructs and prepares (compiled by the SQLite library) an SQL statement in the context of the provided \ndb\n. Note the SQL statement is not actually executed, but only compiled (mainly for usage where the same statement is repeated with different parameters bound as values. See \nbind!\n below).\n\n\nThe \nSQLite.Stmt\n will automatically closed/shutdown when it goes out of scope (i.e. the end of the Julia session, end of a function call wherein it was created, etc.)\n  * \nSQLite.bind!(stmt::SQLite.Stmt,index,value)\n\n\nUsed to bind values to parameter placeholders in an prepared \nSQLite.Stmt\n. From the SQLite documentation:\n\n\n\n\nUsually, though, it is not useful to evaluate exactly the same SQL statement more than once. More often, one wants to evaluate similar statements. For example, you might want to evaluate an INSERT statement multiple times though with different values to insert. To accommodate this kind of flexibility, SQLite allows SQL statements to contain parameters which are \"bound\" to values prior to being evaluated. These values can later be changed and the same prepared statement can be evaluated a second time using the new values.\n\n\nIn SQLite, wherever it is valid to include a string literal, one can use a parameter in one of the following forms:\n\n\n? ?NNN :AAA :AAA @AAA\n\n\nIn the examples above, NNN is an integer value and AAA is an identifier. A parameter initially has a value of NULL. Prior to calling sqlite3_step() for the first time or immediately after sqlite3_reset(), the application can invoke one of the sqlite3_bind() interfaces to attach values to the parameters. Each call to sqlite3_bind() overrides prior bindings on the same parameter.\n  * \nSQLite.execute!(stmt::SQLite.Stmt)\n \nSQLite.execute!(db::SQLite.DB, sql::String)\n\n\n\n\nUsed to execute a prepared \nSQLite.Stmt\n. The 2nd method is a convenience method to pass in an SQL statement as a string which gets prepared and executed in one call. This method does not check for or return any results, hence it is only useful for database manipulation methods (i.e. ALTER, CREATE, UPDATE, DROP). To return results, see \nSQLite.query\n below.\n  * \nSQLite.query(db::SQLite.DB, sql::String, values=[])\n\n\nAn SQL statement \nsql\n is prepared, executed in the context of \ndb\n, and results, if any, are returned. The return value is a \nData.Table\n by default from the \nDataStreams.jl\n package. The \nData.Table\n has a field \n.data\n which is a \nVector{NullableVector}\n which holds the columns of data returned from the \nsql\n statement.\n\n\nThe values in \nvalues\n are used in parameter binding (see \nbind!\n above). If your statement uses nameless parameters \nvalues\n must be a \nVector\n of the values you wish to bind to your statment. If your statement uses named parameters \nvalues\n must be a Dict where the keys are of type \nSymbol\n. The key must match an identifier name in the statement (the name \nshould not\n include the ':', '@' or ':($(Expr(:incomplete, \"incomplete: invalid character literal\")))\n  * \nSQLite.drop!(db::SQLite.DB,table::String;ifexists::Bool=false)\n \nSQLite.dropindex!(db::SQLite.DB,index::String;ifexists::Bool=false)\n\n\nThese are pretty self-explanatory. They're really just a convenience methods to execute DROP TABLE/DROP INDEX commands, while also calling \"VACUUM\" to clean out freed memory from the database.\n  * \nSQLite.createindex!(db::DB,table::AbstractString,index::AbstractString,cols;unique::Bool=true,ifnotexists::Bool=false)\n\n\nCreate a new index named \nindex\n for \ntable\n with the columns in \ncols\n, which should be a comma delimited list of column names. \nunique\n indicates whether the index will have unique values or not. \nifnotexists\n will not throw an error if the index already exists.\n  * \nSQLite.removeduplicates!(db,table::AbstractString,cols::AbstractString)\n\n\nA convenience method for the common task of removing duplicate rows in a dataset according to some subset of columns that make up a \"primary key\".\n  * \nSQLite.tables(db::SQLite.DB)\n\n\nList the tables in an SQLite database \ndb\n\n  * \nSQLite.columns(db::SQLite.DB,table::AbstractString)\n\n\nList the columns in an SQLite table\n  * \nSQLite.indices(db::SQLite.DB)\n\n\nList the indices that have been created in \ndb\n\n  * \nSQLite.Source(db::DB, sql; rows=0, stricttypes::Bool=true)\n\n\nCreate an \nSQLite.Source\n type in \ndb\n with the SQL statement \nsql\n. This prepares and executes the statement, but does not return any data. The source is ready to be streamed to any sink type with an appropriate \nData.stream!\n method defined. \nrows\n can be used to fetch a specific number of rows if known before hand and can help in pre-allocating for sinks. \nstricttypes=false\n can be used to relax type requirements on returned columns; typically, each value in a column must be of the same type, but SQLite itself uses a fairly weak typing scheme which allows any value to be in a column, regardless of type. Working with data in Julia is much more useful in strongly-typed structures, so by default we try to return strongly-typed columns, but this can be relaxed.\n  * \nSQLite.Source(sink::SQLite.Sink,sql)\n\n\nCreates an \nSQLite.Source\n type according the \nsql\n command executed in the same \ndb\n as \nsink\n. By default, the \nsql\n command is \nselect * from $(sink.tablename)\n.\n  * \nData.stream!(source::SQLite.Source,::Type{Data.Table})\n\n\nCreate a \nData.Table\n and stream the data from an \nSQLite.Source\n into it.\n  * \nData.stream!(source::SQLite.Source,sink::CSV.Sink;header::Bool=true)\n\n\nstream the data from \nsource\n to a \nCSV.Sink\n. \nheader\n indicates whether the column names will be written first to \nsink\n.\n  * \nSQLite.Sink(schema::Data.Schema,db::DB,tablename;temp::Bool=false,ifnotexists::Bool=true)\n\n\nCreate a new SQLite table as a sink to stream data to in \ndb\n. \nschema\n is used to create the column names and types. If no \ntablename\n is supplied, one will be generated. \ntemp\n indicates whether the table will be temporary, i.e. if it will be automatically destroyed when the \ndb\n is closed.\n  * \nSQLite.Sink(source::Data.Source, db::DB, tablename)\n  \n\n\nCreate a new SQLite table as a sink in \ndb\n according to the \nData.schema(source)\n.\n  * \nData.stream!(dt::Data.Table,sink::SQLite.Sink)\n\n\nstream the data from a \nData.Table\n to \nsink\n\n  * \nData.stream!(source::CSV.Source,sink::SQLite.Sink)\n\n\nstream the data from a \nCSV.Source\n to \nsink\n\n  * \nSQLite.register(db::SQLite.DB, func::Function; nargs::Int=-1, name::AbstractString=string(func), isdeterm::Bool=true)\n\n  * \nSQLite.register(db::SQLite.DB, init, step::Function, final::Function=identity; nargs::Int=-1, name::AbstractString=string(final), isdeterm::Bool=true)\n\n\nRegister a scalar (first method) or aggregate (second method) function with a \nSQLite.DB\n.\n  * \n@register db function\n\n\nAutomatically define then register \nfunction\n with a \nSQLite.DB\n.\n  * \nsr\"...\"\n\n\nThis string literal is used to escape all special characters in the string, useful for using regex in a query.\n  * \nSQLite.sqlreturn(contex, val)\n\n\nThis function should never be called explicitly. Instead it is exported so that it can be overloaded when necessary, see below.\n\n\n\n\n\n\n\n\nUser Defined Functions\n\n\n\n\nSQLite Regular Expressions\n\n\nSQLite provides syntax for calling the \nregexp\n function\n from inside \nWHERE\n clauses. Unfortunately, however, SQLite does not provide a default implementation of the \nregexp\n function so SQLite.jl creates one automatically when you open a database. The function can be called in the following ways (examples using the \nChinook Database\n)\n\n\njulia\n using SQLite\n\njulia\n db = SQLite.DB(\nChinook_Sqlite.sqlite\n)\n\njulia\n # using SQLite's in-built syntax\n\njulia\n SQLite.query(db, \nSELECT FirstName, LastName FROM Employee WHERE LastName REGEXP 'e(?=a)'\n)\n1x2 ResultSet\n| Row | \nFirstName\n | \nLastName\n |\n|-----|-------------|------------|\n| 1   | \nJane\n      | \nPeacock\n  |\n\njulia\n # explicitly calling the regexp() function\n\njulia\n SQLite.query(db, \nSELECT * FROM Genre WHERE regexp('e[trs]', Name)\n)\n6x2 ResultSet\n| Row | \nGenreId\n | \nName\n               |\n|-----|-----------|----------------------|\n| 1   | 3         | \nMetal\n              |\n| 2   | 4         | \nAlternative \n Punk\n |\n| 3   | 6         | \nBlues\n              |\n| 4   | 13        | \nHeavy Metal\n        |\n| 5   | 23        | \nAlternative\n        |\n| 6   | 25        | \nOpera\n              |\n\njulia\n # you can even do strange things like this if you really want\n\njulia\n SQLite.query(db, \nSELECT * FROM Genre ORDER BY GenreId LIMIT 2\n)\n2x2 ResultSet\n| Row | \nGenreId\n | \nName\n |\n|-----|-----------|--------|\n| 1   | 1         | \nRock\n |\n| 2   | 2         | \nJazz\n |\n\njulia\n SQLite.query(db, \nINSERT INTO Genre VALUES (regexp('^word', 'this is a string'), 'My Genre')\n)\n1x1 ResultSet\n| Row | \nRows Affected\n |\n|-----|-----------------|\n| 1   | 0               |\n\njulia\n SQLite.query(db, \nSELECT * FROM Genre ORDER BY GenreId LIMIT 2\n)\n2x2 ResultSet\n| Row | \nGenreId\n | \nName\n     |\n|-----|-----------|------------|\n| 1   | 0         | \nMy Genre\n |\n| 2   | 1         | \nRock\n     |\n\n\n\n\nDue to the heavy use of escape characters you may run into problems where julia parses out some backslashes in your query, for example \n\"\\y\"\n simply becomes \n\"y\"\n. For example the following two queries are identical\n\n\njulia\n SQLite.query(db, \nSELECT * FROM MediaType WHERE Name REGEXP '-\\d'\n)\n1x1 ResultSet\n| Row | \nRows Affected\n |\n|-----|-----------------|\n| 1   | 0               |\n\njulia\n SQLite.query(db, \nSELECT * FROM MediaType WHERE Name REGEXP '-d'\n)\n1x1 ResultSet\n| Row | \nRows Affected\n |\n|-----|-----------------|\n| 1   | 0               |\n\n\n\n\nThis can be avoided in two ways. You can either escape each backslash yourself or you can use the sr\"...\" string literal that SQLite.jl exports. The previous query can then successfully be run like so\n\n\njulia\n # manually escaping backslashes\n\njulia\n SQLite.query(db, \nSELECT * FROM MediaType WHERE Name REGEXP '-\\\\d'\n)\n1x2 ResultSet\n| Row | \nMediaTypeId\n | \nName\n                        |\n|-----|---------------|-------------------------------|\n| 1   | 3             | \nProtected MPEG-4 video file\n |\n\njulia\n # using sr\n...\n\n\njulia\n SQLite.query(db, sr\nSELECT * FROM MediaType WHERE Name REGEXP '-\\d'\n)\n1x2 ResultSet\n| Row | \nMediaTypeId\n | \nName\n                        |\n|-----|---------------|-------------------------------|\n| 1   | 3             | \nProtected MPEG-4 video file\n |\n\n\n\n\nThe sr\"...\" currently escapes all special characters in a string but it may be changed in the future to escape only characters which are part of a regex.\n\n\n\n\nCustom Scalar Functions\n\n\nSQLite.jl also provides a way that you can implement your own \nScalar Functions\n. This is done using the \nregister\n function and macro.\n\n\n@register\n takes a \nSQLite.DB\n and a function. The function can be in block syntax\n\n\njulia\n @register db function add3(x)\n       x + 3\n       end\n\n\n\n\ninline function syntax\n\n\njulia\n @register db mult3(x) = 3 * x\n\n\n\n\nand previously defined functions\n\n\njulia\n @register db sin\n\n\n\n\nThe \nSQLite.register\n function takes optional arguments; \nnargs\n which defaults to \n-1\n, \nname\n which defaults to the name of the function, \nisdeterm\n which defaults to \ntrue\n. In practice these rarely need to be used.\n\n\nThe \nSQLite.register\n function uses the \nsqlreturn\n function to return your function's return value to SQLite. By default, \nsqlreturn\n maps the returned value to a \nnative SQLite type\n or, failing that, serializes the julia value and stores it as a \nBLOB\n. To change this behaviour simply define a new method for \nsqlreturn\n which then calls a previously defined method for \nsqlreturn\n. Methods which map to native SQLite types are\n\n\nsqlreturn(context, ::NullType)\nsqlreturn(context, val::Int32)\nsqlreturn(context, val::Int64)\nsqlreturn(context, val::Float64)\nsqlreturn(context, val::UTF16String)\nsqlreturn(context, val::String)\nsqlreturn(context, val::Any)\n\n\n\n\nAs an example, say you would like \nBigInt\ns to be stored as \nTEXT\n rather than a \nBLOB\n. You would simply need to define the following method\n\n\nsqlreturn(context, val::BigInt) = sqlreturn(context, string(val))\n\n\n\n\nAnother example is the \nsqlreturn\n used by the \nregexp\n function. For \nregexp\n to work correctly it must return it must return an \nInt\n (more specifically a \n0\n or \n1\n) but \nismatch\n (used by \nregexp\n) returns a \nBool\n. For this reason the following method was defined\n\n\nsqlreturn(context, val::Bool) = sqlreturn(context, int(val))\n\n\n\n\nAny new method defined for \nsqlreturn\n must take two arguments and must pass the first argument straight through as the first argument.\n\n\n\n\nCustom Aggregate Functions\n\n\nUsing the \nSQLite.register\n function, you can also define your own aggregate functions with largely the same semantics.\n\n\nThe \nSQLite.register\n function for aggregates must take a \nSQLite.DB\n, an initial value, a step function and a final function. The first argument to the step function will be the return value of the previous function (or the initial value if it is the first iteration). The final function must take a single argument which will be the return value of the last step function.\n\n\njulia\n dsum(prev, cur) = prev + cur\n\njulia\n dsum(prev) = 2 * prev\n\njulia\n SQLite.register(db, 0, dsum, dsum)\n\n\n\n\nIf no name is given the name of the first (step) function is used (in this case \"dsum\"). You can also use lambdas, the following does the same as the previous code snippet\n\n\njulia\n SQLite.register(db, 0, (p,c) -\n p+c, p -\n 2p, name=\ndsum\n)", 
            "title": "Home"
        }, 
        {
            "location": "/#sqlitejl-documentation", 
            "text": "SQLite.jl Documentation  High-level interface  Lower-level utilities", 
            "title": "SQLite.jl Documentation"
        }, 
        {
            "location": "/#high-level-interface", 
            "text": "#  SQLite.query     Function .  SQLite.query(db, sql::String, sink=DataFrame, values=[]; rows::Int=0, stricttypes::Bool=true)  convenience method for executing an SQL statement and streaming the results back in a  Data.Sink  (DataFrame by default)  Will bind  values  to any parameters in  sql .  rows  is used to indicate how many rows to return in the query result if known beforehand.  rows=0  (the default) will return all possible rows.  stricttypes=false  will remove strict column typing in the result set, making each column effectively  Vector{Any}  source  #  SQLite.load     Function .  Load a Data.Source  source  into an SQLite table that will be named  tablename  (will be auto-generated if not specified).  temp=true  will create a temporary SQLite table that will be destroyed automatically when the database is closed  ifnotexists=false  will throw an error if  tablename  already exists in  db  source", 
            "title": "High-level interface"
        }, 
        {
            "location": "/#lower-level-utilities", 
            "text": "#  SQLite.Source     Type .  SQLite.Source  implements the  Source  interface in the  DataStreams  framework  source  #  SQLite.Sink     Type .  SQLite.Sink implements the  Sink  interface in the  DataStreams  framework  source", 
            "title": "Lower-level utilities"
        }, 
        {
            "location": "/#typesfunctions", 
            "text": "SQLite.DB(file::AbstractString)  SQLite.DB  requires the  file  string argument as the name of either a pre-defined SQLite database to be opened, or if the file doesn't exist, a database will be created.  The  SQLite.DB  object represents a single connection to an SQLite database. All other SQLite.jl functions take an  SQLite.DB  as the first argument as context.  To create an in-memory temporary database, call  SQLite.DB() .  The  SQLite.DB  will automatically closed/shutdown when it goes out of scope (i.e. the end of the Julia session, end of a function call wherein it was created, etc.)\n  *  SQLite.Stmt(db::SQLite.DB, sql::String)  Constructs and prepares (compiled by the SQLite library) an SQL statement in the context of the provided  db . Note the SQL statement is not actually executed, but only compiled (mainly for usage where the same statement is repeated with different parameters bound as values. See  bind!  below).  The  SQLite.Stmt  will automatically closed/shutdown when it goes out of scope (i.e. the end of the Julia session, end of a function call wherein it was created, etc.)\n  *  SQLite.bind!(stmt::SQLite.Stmt,index,value)  Used to bind values to parameter placeholders in an prepared  SQLite.Stmt . From the SQLite documentation:   Usually, though, it is not useful to evaluate exactly the same SQL statement more than once. More often, one wants to evaluate similar statements. For example, you might want to evaluate an INSERT statement multiple times though with different values to insert. To accommodate this kind of flexibility, SQLite allows SQL statements to contain parameters which are \"bound\" to values prior to being evaluated. These values can later be changed and the same prepared statement can be evaluated a second time using the new values.  In SQLite, wherever it is valid to include a string literal, one can use a parameter in one of the following forms:  ? ?NNN :AAA :AAA @AAA  In the examples above, NNN is an integer value and AAA is an identifier. A parameter initially has a value of NULL. Prior to calling sqlite3_step() for the first time or immediately after sqlite3_reset(), the application can invoke one of the sqlite3_bind() interfaces to attach values to the parameters. Each call to sqlite3_bind() overrides prior bindings on the same parameter.\n  *  SQLite.execute!(stmt::SQLite.Stmt)   SQLite.execute!(db::SQLite.DB, sql::String)   Used to execute a prepared  SQLite.Stmt . The 2nd method is a convenience method to pass in an SQL statement as a string which gets prepared and executed in one call. This method does not check for or return any results, hence it is only useful for database manipulation methods (i.e. ALTER, CREATE, UPDATE, DROP). To return results, see  SQLite.query  below.\n  *  SQLite.query(db::SQLite.DB, sql::String, values=[])  An SQL statement  sql  is prepared, executed in the context of  db , and results, if any, are returned. The return value is a  Data.Table  by default from the  DataStreams.jl  package. The  Data.Table  has a field  .data  which is a  Vector{NullableVector}  which holds the columns of data returned from the  sql  statement.  The values in  values  are used in parameter binding (see  bind!  above). If your statement uses nameless parameters  values  must be a  Vector  of the values you wish to bind to your statment. If your statement uses named parameters  values  must be a Dict where the keys are of type  Symbol . The key must match an identifier name in the statement (the name  should not  include the ':', '@' or ':($(Expr(:incomplete, \"incomplete: invalid character literal\")))\n  *  SQLite.drop!(db::SQLite.DB,table::String;ifexists::Bool=false)   SQLite.dropindex!(db::SQLite.DB,index::String;ifexists::Bool=false)  These are pretty self-explanatory. They're really just a convenience methods to execute DROP TABLE/DROP INDEX commands, while also calling \"VACUUM\" to clean out freed memory from the database.\n  *  SQLite.createindex!(db::DB,table::AbstractString,index::AbstractString,cols;unique::Bool=true,ifnotexists::Bool=false)  Create a new index named  index  for  table  with the columns in  cols , which should be a comma delimited list of column names.  unique  indicates whether the index will have unique values or not.  ifnotexists  will not throw an error if the index already exists.\n  *  SQLite.removeduplicates!(db,table::AbstractString,cols::AbstractString)  A convenience method for the common task of removing duplicate rows in a dataset according to some subset of columns that make up a \"primary key\".\n  *  SQLite.tables(db::SQLite.DB)  List the tables in an SQLite database  db \n  *  SQLite.columns(db::SQLite.DB,table::AbstractString)  List the columns in an SQLite table\n  *  SQLite.indices(db::SQLite.DB)  List the indices that have been created in  db \n  *  SQLite.Source(db::DB, sql; rows=0, stricttypes::Bool=true)  Create an  SQLite.Source  type in  db  with the SQL statement  sql . This prepares and executes the statement, but does not return any data. The source is ready to be streamed to any sink type with an appropriate  Data.stream!  method defined.  rows  can be used to fetch a specific number of rows if known before hand and can help in pre-allocating for sinks.  stricttypes=false  can be used to relax type requirements on returned columns; typically, each value in a column must be of the same type, but SQLite itself uses a fairly weak typing scheme which allows any value to be in a column, regardless of type. Working with data in Julia is much more useful in strongly-typed structures, so by default we try to return strongly-typed columns, but this can be relaxed.\n  *  SQLite.Source(sink::SQLite.Sink,sql)  Creates an  SQLite.Source  type according the  sql  command executed in the same  db  as  sink . By default, the  sql  command is  select * from $(sink.tablename) .\n  *  Data.stream!(source::SQLite.Source,::Type{Data.Table})  Create a  Data.Table  and stream the data from an  SQLite.Source  into it.\n  *  Data.stream!(source::SQLite.Source,sink::CSV.Sink;header::Bool=true)  stream the data from  source  to a  CSV.Sink .  header  indicates whether the column names will be written first to  sink .\n  *  SQLite.Sink(schema::Data.Schema,db::DB,tablename;temp::Bool=false,ifnotexists::Bool=true)  Create a new SQLite table as a sink to stream data to in  db .  schema  is used to create the column names and types. If no  tablename  is supplied, one will be generated.  temp  indicates whether the table will be temporary, i.e. if it will be automatically destroyed when the  db  is closed.\n  *  SQLite.Sink(source::Data.Source, db::DB, tablename)     Create a new SQLite table as a sink in  db  according to the  Data.schema(source) .\n  *  Data.stream!(dt::Data.Table,sink::SQLite.Sink)  stream the data from a  Data.Table  to  sink \n  *  Data.stream!(source::CSV.Source,sink::SQLite.Sink)  stream the data from a  CSV.Source  to  sink \n  *  SQLite.register(db::SQLite.DB, func::Function; nargs::Int=-1, name::AbstractString=string(func), isdeterm::Bool=true) \n  *  SQLite.register(db::SQLite.DB, init, step::Function, final::Function=identity; nargs::Int=-1, name::AbstractString=string(final), isdeterm::Bool=true)  Register a scalar (first method) or aggregate (second method) function with a  SQLite.DB .\n  *  @register db function  Automatically define then register  function  with a  SQLite.DB .\n  *  sr\"...\"  This string literal is used to escape all special characters in the string, useful for using regex in a query.\n  *  SQLite.sqlreturn(contex, val)  This function should never be called explicitly. Instead it is exported so that it can be overloaded when necessary, see below.", 
            "title": "Types/Functions"
        }, 
        {
            "location": "/#user-defined-functions", 
            "text": "", 
            "title": "User Defined Functions"
        }, 
        {
            "location": "/#sqlite-regular-expressions", 
            "text": "SQLite provides syntax for calling the  regexp  function  from inside  WHERE  clauses. Unfortunately, however, SQLite does not provide a default implementation of the  regexp  function so SQLite.jl creates one automatically when you open a database. The function can be called in the following ways (examples using the  Chinook Database )  julia  using SQLite\n\njulia  db = SQLite.DB( Chinook_Sqlite.sqlite )\n\njulia  # using SQLite's in-built syntax\n\njulia  SQLite.query(db,  SELECT FirstName, LastName FROM Employee WHERE LastName REGEXP 'e(?=a)' )\n1x2 ResultSet\n| Row |  FirstName  |  LastName  |\n|-----|-------------|------------|\n| 1   |  Jane       |  Peacock   |\n\njulia  # explicitly calling the regexp() function\n\njulia  SQLite.query(db,  SELECT * FROM Genre WHERE regexp('e[trs]', Name) )\n6x2 ResultSet\n| Row |  GenreId  |  Name                |\n|-----|-----------|----------------------|\n| 1   | 3         |  Metal               |\n| 2   | 4         |  Alternative   Punk  |\n| 3   | 6         |  Blues               |\n| 4   | 13        |  Heavy Metal         |\n| 5   | 23        |  Alternative         |\n| 6   | 25        |  Opera               |\n\njulia  # you can even do strange things like this if you really want\n\njulia  SQLite.query(db,  SELECT * FROM Genre ORDER BY GenreId LIMIT 2 )\n2x2 ResultSet\n| Row |  GenreId  |  Name  |\n|-----|-----------|--------|\n| 1   | 1         |  Rock  |\n| 2   | 2         |  Jazz  |\n\njulia  SQLite.query(db,  INSERT INTO Genre VALUES (regexp('^word', 'this is a string'), 'My Genre') )\n1x1 ResultSet\n| Row |  Rows Affected  |\n|-----|-----------------|\n| 1   | 0               |\n\njulia  SQLite.query(db,  SELECT * FROM Genre ORDER BY GenreId LIMIT 2 )\n2x2 ResultSet\n| Row |  GenreId  |  Name      |\n|-----|-----------|------------|\n| 1   | 0         |  My Genre  |\n| 2   | 1         |  Rock      |  Due to the heavy use of escape characters you may run into problems where julia parses out some backslashes in your query, for example  \"\\y\"  simply becomes  \"y\" . For example the following two queries are identical  julia  SQLite.query(db,  SELECT * FROM MediaType WHERE Name REGEXP '-\\d' )\n1x1 ResultSet\n| Row |  Rows Affected  |\n|-----|-----------------|\n| 1   | 0               |\n\njulia  SQLite.query(db,  SELECT * FROM MediaType WHERE Name REGEXP '-d' )\n1x1 ResultSet\n| Row |  Rows Affected  |\n|-----|-----------------|\n| 1   | 0               |  This can be avoided in two ways. You can either escape each backslash yourself or you can use the sr\"...\" string literal that SQLite.jl exports. The previous query can then successfully be run like so  julia  # manually escaping backslashes\n\njulia  SQLite.query(db,  SELECT * FROM MediaType WHERE Name REGEXP '-\\\\d' )\n1x2 ResultSet\n| Row |  MediaTypeId  |  Name                         |\n|-----|---------------|-------------------------------|\n| 1   | 3             |  Protected MPEG-4 video file  |\n\njulia  # using sr ... \n\njulia  SQLite.query(db, sr SELECT * FROM MediaType WHERE Name REGEXP '-\\d' )\n1x2 ResultSet\n| Row |  MediaTypeId  |  Name                         |\n|-----|---------------|-------------------------------|\n| 1   | 3             |  Protected MPEG-4 video file  |  The sr\"...\" currently escapes all special characters in a string but it may be changed in the future to escape only characters which are part of a regex.", 
            "title": "SQLite Regular Expressions"
        }, 
        {
            "location": "/#custom-scalar-functions", 
            "text": "SQLite.jl also provides a way that you can implement your own  Scalar Functions . This is done using the  register  function and macro.  @register  takes a  SQLite.DB  and a function. The function can be in block syntax  julia  @register db function add3(x)\n       x + 3\n       end  inline function syntax  julia  @register db mult3(x) = 3 * x  and previously defined functions  julia  @register db sin  The  SQLite.register  function takes optional arguments;  nargs  which defaults to  -1 ,  name  which defaults to the name of the function,  isdeterm  which defaults to  true . In practice these rarely need to be used.  The  SQLite.register  function uses the  sqlreturn  function to return your function's return value to SQLite. By default,  sqlreturn  maps the returned value to a  native SQLite type  or, failing that, serializes the julia value and stores it as a  BLOB . To change this behaviour simply define a new method for  sqlreturn  which then calls a previously defined method for  sqlreturn . Methods which map to native SQLite types are  sqlreturn(context, ::NullType)\nsqlreturn(context, val::Int32)\nsqlreturn(context, val::Int64)\nsqlreturn(context, val::Float64)\nsqlreturn(context, val::UTF16String)\nsqlreturn(context, val::String)\nsqlreturn(context, val::Any)  As an example, say you would like  BigInt s to be stored as  TEXT  rather than a  BLOB . You would simply need to define the following method  sqlreturn(context, val::BigInt) = sqlreturn(context, string(val))  Another example is the  sqlreturn  used by the  regexp  function. For  regexp  to work correctly it must return it must return an  Int  (more specifically a  0  or  1 ) but  ismatch  (used by  regexp ) returns a  Bool . For this reason the following method was defined  sqlreturn(context, val::Bool) = sqlreturn(context, int(val))  Any new method defined for  sqlreturn  must take two arguments and must pass the first argument straight through as the first argument.", 
            "title": "Custom Scalar Functions"
        }, 
        {
            "location": "/#custom-aggregate-functions", 
            "text": "Using the  SQLite.register  function, you can also define your own aggregate functions with largely the same semantics.  The  SQLite.register  function for aggregates must take a  SQLite.DB , an initial value, a step function and a final function. The first argument to the step function will be the return value of the previous function (or the initial value if it is the first iteration). The final function must take a single argument which will be the return value of the last step function.  julia  dsum(prev, cur) = prev + cur\n\njulia  dsum(prev) = 2 * prev\n\njulia  SQLite.register(db, 0, dsum, dsum)  If no name is given the name of the first (step) function is used (in this case \"dsum\"). You can also use lambdas, the following does the same as the previous code snippet  julia  SQLite.register(db, 0, (p,c) -  p+c, p -  2p, name= dsum )", 
            "title": "Custom Aggregate Functions"
        }
    ]
}